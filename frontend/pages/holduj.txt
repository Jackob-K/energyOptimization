import reflex as rx
import sqlite3
from datetime import datetime, timedelta
from ..templates import template
from ..components.card import card
from ..components.charts import ChartState
from .. import styles
from backend.database import get_db  # ‚úÖ Naƒçteme va≈°i funkci pro DB p≈ôipojen√≠

# ‚úÖ Stavy pro datum a interval
class EnergyChartState(rx.State):
    """Spr√°va stavu hlavn√≠ho grafu (v√Ωroba/spot≈ôeba)."""
    current_date: str = datetime.today().strftime("%Y-%m-%d")
    selected_interval: str = "month"
    chart_data: list = []

    def fetch_data(self):
        """Naƒç√≠t√° data z datab√°ze pro hlavn√≠ graf podle vybran√©ho intervalu."""
        conn = get_db()
        cursor = conn.cursor()
        end_date = datetime.strptime(self.current_date, "%Y-%m-%d")

        if self.selected_interval == "day":
            start_date = end_date.strftime("%Y-%m-%d")
            query = """
                SELECT date || ' ' || hour, fveProduction, consumption, consumptionPredicted, fvePredicted
                FROM energyData
                WHERE date = ? AND hour != 24
                ORDER BY date ASC, hour ASC
            """
            cursor.execute(query, (start_date,))

        elif self.selected_interval == "week":
            start_date = (end_date - timedelta(days=end_date.weekday())).strftime("%Y-%m-%d")
            end_date = (datetime.strptime(start_date, "%Y-%m-%d") + timedelta(days=6)).strftime("%Y-%m-%d")
            query = """
                SELECT date || ' ' || hour, fveProduction, consumption, consumptionPredicted, fvePredicted
                FROM energyData
                WHERE date BETWEEN ? AND ? AND hour != 24
                ORDER BY date ASC, hour ASC
            """
            cursor.execute(query, (start_date, end_date))

        elif self.selected_interval == "month":
            start_date = end_date.replace(day=1).strftime("%Y-%m-%d")
            end_date = (datetime.strptime(start_date, "%Y-%m-%d") + timedelta(days=32)).replace(day=1) - timedelta(days=1)
            end_date = end_date.strftime("%Y-%m-%d")
            query = """
                SELECT date, 
                    SUM(fveProduction) AS fveProduction, 
                    SUM(consumption) AS consumption, 
                    COALESCE(SUM(consumptionPredicted), 0) AS consumptionPredicted, 
                    COALESCE(SUM(fvePredicted), 0) AS fvePredicted
                FROM energyData
                WHERE date BETWEEN ? AND ?
                GROUP BY date
                ORDER BY date ASC
            """
            cursor.execute(query, (start_date, end_date))

        else:  # "year"
            start_date = end_date.replace(month=1, day=1).strftime("%Y-%m-%d")
            end_date = end_date.replace(month=12, day=31).strftime("%Y-%m-%d")
            query = """
                SELECT SUBSTR(date, 1, 7) AS month, SUM(fveProduction), SUM(consumption), SUM(consumptionPredicted), SUM(fvePredicted)
                FROM energyData
                WHERE date BETWEEN ? AND ? AND hour = 24
                GROUP BY month
                ORDER BY month ASC
            """
            cursor.execute(query, (start_date, end_date))

        data = cursor.fetchall()
        conn.close()

        # ‚úÖ Seznam pro zpracovan√° data
        processed_data = []
        last_real_consumption = None
        last_real_fve = None
        last_real_timestamp = None  # Posledn√≠ re√°ln√© datum
        predicted_started = False

        for row in data:
            timestamp, production, real_consumption, predicted_consumption, predicted_fve = row
            if self.selected_interval == "year":
                timestamp_date = datetime.strptime(timestamp, "%Y-%m")  # Spr√°vn√Ω form√°t pro roƒçn√≠ data
            else:
                timestamp_date = datetime.strptime(timestamp.split(" ")[0], "%Y-%m-%d")  # Ostatn√≠ p≈ô√≠pady

            # ‚úÖ Re√°ln√© hodnoty jsou zobrazeny norm√°lnƒõ
            if real_consumption is not None:
                last_real_consumption = real_consumption
                last_real_fve = production
                last_real_timestamp = timestamp_date  # Ulo≈æ√≠me posledn√≠ zn√°m√© datum re√°ln√Ωch dat
                processed_data.append({
                    "timestamp": timestamp,
                    "production": production,
                    "consumption": real_consumption,
                    "consumptionPredicted": None,
                    "fvePredicted": None,
                })
            else:
                # ‚úÖ Jakmile najdeme prvn√≠ predikovan√© hodnoty, rozhodneme, zda p≈ôidat spojovac√≠ bod
                if not predicted_started and last_real_consumption is not None:
                    predicted_started = True
                    if last_real_timestamp is not None:
                        days_gap = (timestamp_date - last_real_timestamp).days  # Rozd√≠l dn≈Ø

                        # ‚úÖ Pokud predikce zaƒç√≠n√° hned po posledn√≠m re√°ln√©m bodu, p≈ôid√°me spojovac√≠ bod
                        if days_gap <= 1:
                            processed_data.append({
                                "timestamp": timestamp,  # Pou≈æijeme aktu√°ln√≠ ƒças predikce
                                "production": last_real_fve,  # Posledn√≠ zn√°m√° hodnota
                                "consumption": last_real_consumption,  # Posledn√≠ zn√°m√° hodnota
                                "consumptionPredicted": last_real_consumption,  # Spojovac√≠ bod
                                "fvePredicted": last_real_fve,  # Spojovac√≠ bod
                            })

                # ‚úÖ Predikovan√© hodnoty se norm√°lnƒõ p≈ôidaj√≠
                processed_data.append({
                    "timestamp": timestamp,
                    "production": None,
                    "consumption": None,
                    "consumptionPredicted": predicted_consumption,
                    "fvePredicted": predicted_fve,
                })

        self.chart_data = processed_data



    def shift_date(self, direction: str):
        """Posune datum dop≈ôedu nebo dozadu podle intervalu."""
        conn = get_db()
        cursor = conn.cursor()

        if direction in ["prev_start", "next_end"]:
            query = "SELECT MIN(date), MAX(date) FROM energyData"
            cursor.execute(query)
            min_date, max_date = cursor.fetchone()
            conn.close()

            if direction == "prev_start":
                self.current_date = min_date
            elif direction == "next_end":
                self.current_date = max_date
        else:
            date_obj = datetime.strptime(self.current_date, "%Y-%m-%d")
            delta = None

            # ‚úÖ Opraven√© podm√≠nky, aby se zabr√°nilo nespr√°vn√©mu skoku
            if self.selected_interval == "day":
                delta = timedelta(days=1)
            elif self.selected_interval == "week":
                delta = timedelta(weeks=1)
            elif self.selected_interval == "month":
                delta = timedelta(days=32)
            elif self.selected_interval == "year":  # ‚úÖ Explicitn√≠ podm√≠nka pro rok
                # ‚úÖ Pro "year" zjist√≠me nejbli≈æ≈°√≠ dostupn√Ω rok v datab√°zi
                current_year = int(self.current_date[:4])

                if direction == "prev":
                    query = "SELECT MAX(SUBSTR(date, 1, 4)) FROM energyData WHERE SUBSTR(date, 1, 4) < ?"
                elif direction == "next":
                    query = "SELECT MIN(SUBSTR(date, 1, 4)) FROM energyData WHERE SUBSTR(date, 1, 4) > ?"
                else:
                    return  # Pokud smƒõr nen√≠ validn√≠, nic nedƒõl√°me

                cursor.execute(query, (str(current_year),))
                next_year = cursor.fetchone()[0]
                conn.close()

                if next_year:
                    self.current_date = f"{next_year}-01-01"  # P≈ôepneme na nov√Ω rok
                    self.fetch_data()  # ‚úÖ Aktualizujeme data pro nov√Ω rok
                else:
                    return  # Ukonƒç√≠me funkci, proto≈æe pro "year" u≈æ nem√° smysl pokraƒçovat


            if direction == "prev":
                date_obj -= delta
            elif direction == "next":
                date_obj += delta

            # ‚úÖ Ujist√≠me se, ≈æe jsme spr√°vnƒõ nastavili nov√Ω zaƒç√°tek obdob√≠
            if self.selected_interval == "week":
                date_obj -= timedelta(days=date_obj.weekday())  # Pondƒõl√≠ dan√©ho t√Ωdne
            elif self.selected_interval == "month":
                date_obj = date_obj.replace(day=1)  # Prvn√≠ den mƒõs√≠ce
            elif self.selected_interval == "year":
                date_obj = date_obj.replace(month=1, day=1)  # 1. leden

            self.current_date = date_obj.strftime("%Y-%m-%d")

        self.fetch_data()

    def set_selected_interval(self, interval: str):
        """Zmƒõn√≠ interval a aktualizuje data."""
        self.selected_interval = interval
        self.fetch_data()

    def set_today(self):
        """Nastav√≠ datum na dne≈°n√≠ den."""
        self.current_date = datetime.today().strftime("%Y-%m-%d")
        self.fetch_data()



class PriceChartState(rx.State):
    """Spr√°va stavu grafu ceny elekt≈ôiny."""
    current_date: str = datetime.today().strftime("%Y-%m-%d")
    price_chart_data: list = []

    def fetch_data(self):
        """Naƒç√≠t√° data z datab√°ze pro graf ceny elekt≈ôiny."""
        conn = get_db()
        cursor = conn.cursor()
        query = """
            SELECT hodina+1, cena, mnozstvi
            FROM energy_prices
            WHERE datum = ?
            ORDER BY hodina ASC
        """
        cursor.execute(query, (self.current_date,))
        price_data = cursor.fetchall()
        conn.close()

        self.price_chart_data = [{"hour": row[0], "price": row[1], "quantity": row[2]} for row in price_data]

    def shift_day(self, direction: str):
        """Posune datum o jeden den vp≈ôed nebo vzad."""
        date_obj = datetime.strptime(self.current_date, "%Y-%m-%d")
        date_obj += timedelta(days=1 if direction == "next" else -1)
        self.current_date = date_obj.strftime("%Y-%m-%d")
        self.fetch_data()

    def set_today(self):
        """Nastav√≠ datum na dne≈°n√≠ den."""
        self.current_date = datetime.today().strftime("%Y-%m-%d")
        self.fetch_data()



############################################################
#                        HLAVN√ç GRAF                       #
############################################################

def energy_chart():
    """Komponenta zobrazuj√≠c√≠ graf s mo≈ænost√≠ p≈ôep√≠n√°n√≠ obdob√≠."""
    return rx.box(
        rx.heading("Graf spot≈ôeby a v√Ωroby", size="4", margin_bottom="1rem"),
        
        card(
            rx.vstack(
                # ‚úÖ V√Ωbƒõr intervalu v lev√©m horn√≠m rohu
                rx.hstack(
                    rx.select(
                        ["day", "week", "month", "year"],  # ‚úÖ P≈ôid√°n "day"
                        value=EnergyChartState.selected_interval,
                        on_change=EnergyChartState.set_selected_interval,
                    ),
                    align="start",
                    width="100%",
                ),

                # üîÑ Navigace tlaƒç√≠tky
                rx.hstack(
                    rx.button(rx.icon("chevrons-left"), on_click=lambda: EnergyChartState.shift_date("prev_start"), style=styles.button_style),
                    rx.button(rx.icon("chevron-left"), on_click=lambda: EnergyChartState.shift_date("prev"), style=styles.button_style),
                    rx.text(EnergyChartState.current_date),
                    rx.button(rx.icon("chevron-right"), on_click=lambda: EnergyChartState.shift_date("next"), style=styles.button_style),
                    rx.button(rx.icon("chevrons-right"), on_click=lambda: EnergyChartState.shift_date("next_end"), style=styles.button_style),
                    spacing="4",
                ),

                # üìà Graf s daty
                rx.recharts.area_chart(
                    rx.recharts.area(
                        data_key="consumption",
                        type_="basis",
                        stroke=styles.graph_consumption_color,
                        stroke_width=2,
                        fill=styles.graph_consumption_fill,
                        fill_opacity=0.3,
                        dot=False,
                    ),
                    rx.recharts.area(
                        data_key="production",
                        type_="basis",
                        stroke=styles.graph_production_color,
                        stroke_width=2,
                        fill=styles.graph_production_fill,
                        fill_opacity=0.3,
                        dot=False,
                    ),
                    rx.recharts.area(
                        data_key="consumptionPredicted",
                        type_="basis",
                        stroke=styles.graph_consumption_predicted_color,
                        stroke_width=2,
                        stroke_dasharray="5 5",  # P≈ôeru≈°ovan√° ƒç√°ra pro predikci
                        fill_opacity=0,
                        dot=False,
                    ),
                    rx.recharts.area(
                        data_key="fvePredicted",
                        type_="basis",
                        stroke=styles.graph_production_predicted_color,
                        stroke_width=2,
                        stroke_dasharray="5 5",  # P≈ôeru≈°ovan√° ƒç√°ra pro predikci
                        fill_opacity=0,
                        dot=False,
                    ),
                    rx.recharts.x_axis(
                        data_key="timestamp",
                        angle=-45,
                        dy=20,
                        tick_size=10,
                        tick_line=False,
                    ),
                    rx.recharts.y_axis(
                        tick_line=False,
                    ),
                    rx.recharts.cartesian_grid(
                        stroke_dasharray="3 3",
                        vertical=False,
                    ),
                    rx.recharts.graphing_tooltip(),
                    rx.recharts.legend(),
                    data=EnergyChartState.chart_data,
                    width="95%",
                    height=500,
                    flex_grow=1,
                ),
                width="100%",  
                flex_grow=1,  
            ),
            width="100%",
            max_width="none",
        ),
        width="calc(85vw - 1rem)",
    )



############################################################
#                         GRAF CEN                        #
############################################################

def price_chart():
    """Komponenta zobrazuj√≠c√≠ denn√≠ ceny elekt≈ôiny."""
    return rx.box(
        rx.heading(f"V√Ωsledky denn√≠ho trhu ƒåR - {PriceChartState.current_date}", size="4"),
        card(
            rx.vstack(

                # üîÑ Navigace ≈°ipkami pro p≈ôep√≠n√°n√≠ dn≈Ø
                rx.hstack(
                    rx.button(rx.icon("chevron-left"), on_click=lambda: PriceChartState.shift_day("prev"), style=styles.button_style),
                    rx.text(PriceChartState.current_date),
                    rx.button(rx.icon("chevron-right"), on_click=lambda: PriceChartState.shift_day("next"), style=styles.button_style),
                    spacing="4",
                ),

                # üìà Graf ceny elekt≈ôiny (line chart) + Mno≈æstv√≠ (bar chart)
                rx.recharts.composed_chart(
                    rx.recharts.line(
                        data_key="price",
                        stroke=styles.graph_price_color,
                        stroke_width=3,
                        dot=True,
                    ),
                    rx.recharts.bar(
                        data_key="quantity",
                        fill=styles.graph_quantity_fill, 
                        bar_size=15,
                        y_axis_id="right",
                    ),
                    rx.recharts.x_axis(
                        data_key="hour",
                        tick_size=10,
                        tick_line=False,
                    ),
                    rx.recharts.y_axis(
                        tick_line=False,
                        label={
                            "value": "Cena (EUR/MWh)",
                            "angle": -90,
                            "position": "outsideLeft",
                            "dx": -20,
                        },
                    ),
                    rx.recharts.y_axis(
                        tick_line=False,
                        y_axis_id="right",
                        orientation="right",
                        label={
                            "value": "Mno≈æstv√≠ (MWh)",
                            "angle": 90,
                            "position": "outsideRight",
                            "dx": 30,
                        },
                    ),
                    rx.recharts.cartesian_grid(
                        stroke_dasharray="3 3",
                        vertical=False,
                    ),
                    rx.recharts.legend(),  # ‚úÖ P≈ôid√°me legendu
                    rx.recharts.graphing_tooltip(),
                    data=PriceChartState.price_chart_data,
                    width="100%",
                    height=500,
                    margin={"left": 10, "right":10,},
                ),
                width="100%",
            ),
            width="100%",  # ‚úÖ Poloviƒçn√≠ ≈°√≠≈ôka
            max_width="100%",
        ),
        width="55%",
    )

############################################################
#                     VYKRESLEN√ç GRAF≈Æ                    #
############################################################

def reset_button():
    return rx.box(
        rx.button(
            "üîÑ Restart na dne≈°n√≠ datum",
            on_click=[EnergyChartState.set_today, PriceChartState.set_today],  
            size="3",  # ‚úÖ Zachov√°n√≠ velikosti tlaƒç√≠tka
            color_scheme="blue",
        ),
        style={
            "position": "absolute",
            "top": "1rem",
            "right": "1rem",
            "z_index": "1000"  # ‚úÖ Ujist√≠ se, ≈æe tlaƒç√≠tko bude nad ostatn√≠mi prvky
        }
    )



@template(route="/dashboard", title="Dashboard")
def page() -> rx.Component:
    return rx.vstack(
        reset_button(),
        energy_chart(),
        rx.hstack(
            price_chart(),
            spacing="4",
            width="100%",
        ),
        spacing="8",
        width="100%",
    )
